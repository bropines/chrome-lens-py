> [!IMPORTANT]  
> Библиотека перешла на Async. Обновите свои проекты !!!!

> [!NOTE]  
> Если вы не хотите разбираться в том что тут в модулях(а тут написана куча мусора), и как перенести это в свой проект, перейдите в `experiments/reverse.py`. Вам его достаточно чтобы разобраться с тем как это все работает. 

# Chrome Lens API для Python

[English](/README.md) | [Русский](/README_RU.md)

Этот проект предоставляет библиотеку Python и CLI инструмент для взаимодействия с функциональностью OCR Google Lens через API, используемое в Chromium. Это позволяет обрабатывать изображения и извлекать текстовые данные, включая полный текст, координаты и сшитый текст, используя различные методы.

## Возможности

- **Извлечение полного текста**: Извлечение основного реконструированного текста с изображения.
- **Извлечение координат**: Извлечение аннотаций слов вместе с их координатами (центральная позиция, размер и угол в градусах).
- **Сшитый текст**: Восстановление текста из аннотаций слов с использованием различных методов:
  - **Умный метод**: Попытка реконструкции строк на основе вертикальных позиций.
  - **Последовательный метод**: Последовательное сшивание на основе порядка распознавания слов.
- **Ввод из различных источников**: Обработка изображений из файловых путей, URL-адресов, объектов [PIL Image](https://pillow.readthedocs.io/en/stable/reference/Image.html) и массивов [NumPy](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html) (включая изображения, считанные с помощью [OpenCV](https://opencv.org/)).
- **Сканирование изображений по URL**: Обработка изображений напрямую по URL без необходимости предварительно их загружать.
- **Управление куки**: Автоматически обрабатывает куки сеанса, сохраняя/загружая их из файла `.pkl`. Может импортировать из файлов формата Netscape или строк через конфигурацию.
- **Поддержка прокси**: Поддержка HTTP, HTTPS и SOCKS4/5 прокси для выполнения запросов через разные сети.
- **Ограничение скорости (Rate Limiting)**: Автоматически контролирует количество запросов в минуту для соблюдения ограничений использования API (настраивается).
- ~~**Выбор типа заголовков**: Выбирайте между различными наборами заголовков запросов.~~ Временно убрано!
- **Multilingual**: In the updated version, if there are several languages in the image, they are now recognized. 
> [!NOTE]
> К сожалению, я не проверял это раньше, поэтому конечным языком будет тот, который был последним в списке ответа сервера.

**Важно: Асинхронный API**

**Эта библиотека теперь использует асинхронные запросы (`asyncio`, `httpx`) для повышения производительности и эффективности. При использовании программного API необходимо использовать `async` и `await` в вашем коде для вызова методов API. Смотрите раздел "Использование API" для примеров.**

_PS: У Google Lens есть проблема с отображением полного текста, поэтому добавлены методы, которые сшивают текст из координат._

## Установка

Вы можете установить пакет, используя `pip`:

### Из PyPI

```bash
pip install chrome-lens-py
```

### Обновление через PyPI

```bash
pip install -U chrome-lens-py
```

### Из GIT

```bash
pip install git+https://github.com/bropines/chrome-lens-py.git
```

### Из исходников

Клонируйте репозиторий и установите пакет:

```bash
git clone https://github.com/bropines/chrome-lens-api-py.git
cd chrome-lens-api-py
pip install -r requirements.txt
pip install .
```

## Использование

Вы можете использовать команду `lens_scan` в CLI для обработки изображений и извлечения текстовых данных, или вы можете использовать Python API для интеграции этой функциональности в ваши собственные проекты.

<details>
  <summary><b>Использование CLI</b></summary>

```bash
lens_scan <image_source> [data_type] [опции]
```

- `<image_source>`: Путь к файлу изображения или URL, или путь к каталогу для пакетной обработки.
- `[data_type]` (опционально): Тип данных для извлечения (по умолчанию: `all`). См. ниже.
- `[опции]`: Дополнительные флаги для настройки поведения.

#### Типы данных

- **`all`**: Получить все данные (язык, полный текст, координаты и сшитый текст с использованием обоих методов).
- **`full_text_default`**: Получить основной реконструированный текст.
- **`full_text_old_method`**: Получить сшитый текст с использованием последовательного метода.
- **`full_text_new_method`**: Получить сшитый текст с использованием умного метода (реконструкция строк).
- **`coordinates`**: Получить аннотации слов с координатами.

#### Опции

- **`-h, --help`**: Показать это справочное сообщение и выйти.
- **`-c, --cookie-file <путь>`**: Путь к файлу cookie в формате Netscape или `.pkl`, используемому библиотекой.
- **`-p, --proxy <URL_прокси>`**: Указать прокси-сервер (например, `http://user:pass@host:port`, `socks5://host:port`).
- **`--config-file <путь>`**: Путь к файлу конфигурации JSON.
- **`--debug=(info|debug)`**: Включить логирование на указанном уровне (`info` или `debug`).
- **`--coordinate-format=(percent|pixels)`**: Формат вывода координат: `'percent'` (по умолчанию) или `'pixels'`.
- **`-st, --sleep-time <миллисекунды>`**: УСТАРЕЛО. Задержка обрабатывается внутренним ограничителем скорости.
- **`-uc, --update-config`**: Обновить файл конфигурации по умолчанию нечувствительными к безопасности аргументами CLI.
- **`--debug-out <путь>`**: Путь для сохранения сырого ответа метаданных (полезно при `--debug=debug`).
- **`--out-txt=(per_file|имя_файла.txt)`**: Опция вывода при обработке каталога: `'per_file'` для вывода каждого результата в отдельный текстовый файл, или указать `имя_файла.txt` для одного общего файла. Если не указано для каталога, результаты выводятся в консоль.
- ~~**`--header-type=(default|custom|chrome)`**: ИГНОРИРУЕТСЯ.~~ Временно убрано!
- **`--rate-limit-rpm <RPM>`**: Установить максимальное количество запросов в минуту (RPM), например, 30. Переопределяет значение из конфига.

#### Примеры

Извлечение текста с использованием умного метода сшивания из локального файла:

```bash
lens_scan путь/к/изображению.jpg full_text_new_method
```

Извлечение текста с использованием умного метода сшивания по URL:

```bash
lens_scan https://example.com/image.jpg full_text_new_method
```

Получение всех доступных данных из локального файла и вывод координат в пикселях:

```bash
lens_scan путь/к/изображению.jpg all --coordinate-format=pixels
```

Обработка всех изображений в каталоге и сохранение результатов в отдельные файлы:

```bash
lens_scan /путь/к/изображениям all --out-txt=per_file
```

Установка ограничения скорости в 30 запросов в минуту:

```bash
lens_scan путь/к/изображению.jpg all --rate-limit-rpm 30
```

#### CLI Справка

Вы можете использовать опцию `-h` или `--help`, чтобы вывести справочную информацию:

```bash
lens_scan -h
```

</details>

<details>
  <summary><b>Использование API</b></summary>

В дополнение к CLI инструменту, этот проект предоставляет Python API, который можно использовать в ваших скриптах.

**Важно: Асинхронный API**

**`LensAPI` разработан для асинхронных операций. Вы ДОЛЖНЫ использовать `async` и `await` при вызове его методов.**

#### Базовое использование API

Сначала импортируйте класс `LensAPI` и `asyncio`:

```python
import asyncio
from chrome_lens_py import LensAPI
```

#### Пример использования API

1.  **Создание экземпляра API**:

    ```python
    # Создание экземпляра LensAPI - он сам настроит клиент
    api = LensAPI()
    # Пример с прокси и отладочным логированием:
    # api = LensAPI(config={'proxy': 'socks5://127.0.0.1:7265'}, logging_level=logging.DEBUG)
    ```

2.  **Обработка изображения внутри `async` функции**:

    Вы можете обрабатывать изображения из различных источников: файловые пути, URL-адреса, объекты PIL Image и массивы NumPy.

    ```python
    import asyncio
    import logging # Для примера установки уровня логирования
    from chrome_lens_py import LensAPI
    from PIL import Image
    import numpy as np

    async def run_lens_tasks():
        # Инициализация API (здесь можно указать прокси, куки, уровень логгирования)
        # Пример: Включить отладочное логирование и установить прокси
        api = LensAPI(
            config={'proxy': 'socks5://127.0.0.1:7265', 'debug_out': 'debug_response.json'},
            logging_level=logging.DEBUG
        )

        image_path = 'd:/bropi/Documents/ShareX/Screenshots/2025-03/NVIDIA_Overlay_GknkEZGEgr.png' # Ваш путь к изображению
        image_url = 'https://www.google.com/images/branding/googlelogo/1x/googlelogo_light_color_272x92dp.png' # Пример URL

        try:
            # --- Тест 1: Получить все данные из локального файла ---
            print("\n--- Тест get_all_data (локальный файл) ---")
            result_all_file = await api.get_all_data(image_path, coordinate_format='pixels')
            print(result_all_file)

            # --- Тест 2: Получить полный текст по URL ---
            print("\n--- Тест get_full_text (URL) ---")
            # Соответствует full_text_default в CLI
            result_text_url = await api.get_full_text(image_url)
            print(result_text_url)

            # --- Тест 3: Получить координаты из PIL Image ---
            print("\n--- Тест get_text_with_coordinates (PIL Image) ---")
            try:
                pil_image = Image.open(image_path)
                result_coords_pil = await api.get_text_with_coordinates(pil_image, coordinate_format='percent')
                print(result_coords_pil)
                pil_image.close()
            except FileNotFoundError:
                print(f"Тест PIL пропущен: Файл изображения не найден по пути {image_path}")
            except Exception as e:
                print(f"Ошибка обработки PIL изображения: {e}")

            # --- Тест 4: Получить умный сшитый текст из массива NumPy ---
            print("\n--- Тест get_stitched_text_smart (массив NumPy) ---")
            # Соответствует full_text_new_method в CLI
            try:
                np_image = np.array(Image.open(image_path)) # Загрузка изображения в массив numpy
                result_smart_np = await api.get_stitched_text_smart(np_image)
                print(result_smart_np)
            except FileNotFoundError:
                print(f"Тест NumPy пропущен: Файл изображения не найден по пути {image_path}")
            except Exception as e:
                print(f"Ошибка обработки массива NumPy: {e}")

            # --- Тест 5: Получить последовательный сшитый текст из локального файла ---
            print("\n--- Тест get_stitched_text_sequential (локальный файл) ---")
            # Соответствует full_text_old_method в CLI
            result_seq_file = await api.get_stitched_text_sequential(image_path)
            print(result_seq_file)

        except Exception as e:
            print(f"\n--- Произошла ошибка во время тестирования: {e} ---")
            logging.exception("Детали ошибки:") # Вывод стека вызовов, если логирование включено
        finally:
            # --- ВАЖНО: Закрыть сессию по завершении ---
            print("\n--- Закрытие сессии API ---")
            await api.close_session()

    if __name__ == "__main__":
        # Базовая настройка логирования для тестового скрипта
        logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(name)s - %(message)s')
        asyncio.run(run_lens_tasks())
    ```

#### Параметры конфигурации

Вы можете настроить поведение `LensAPI`, передав словарь `config` и другие параметры при создании экземпляра класса. Это позволяет вам контролировать различные аспекты API, такие как прокси, управление куки, отладку и ограничение скорости.

Конструктор `LensAPI` принимает следующие параметры:

-   **`config` (dict, optional)**: Словарь, содержащий параметры конфигурации (подробности смотрите ниже).
-   **`sleep_time` (int, optional)**: УСТАРЕЛО. Внутренний ограничитель скорости обрабатывает задержки. Параметр игнорируется.
-   **`logging_level` (int, optional)**: Устанавливает уровень логирования для API. Использует уровни модуля `logging` Python (например, `logging.DEBUG`, `logging.INFO`, `logging.WARNING`). По умолчанию `logging.WARNING`. Может быть переопределено параметром `debug` в `config`.
-   **`rate_limit_rpm` (int, optional)**: Устанавливает максимальное количество запросов в минуту (RPM) для ограничения скорости. Переопределяет `rate_limiting` в `config`. Обрабатывается внутри.

Следующие ключи могут быть использованы в словаре `config`:

-   **`proxy`**: указывает прокси-сервер для отправки запросов. Поддерживает прокси-серверы HTTP, HTTPS и SOCKS.
    ```python
    api = LensAPI(config={'proxy': 'socks5://127.0.0.1:7265'})
    ```

-   **`cookies`**: управляет куки для сеанса. Может быть путем к файлу cookie формата Netscape для первоначального импорта, строкой cookie или словарем cookie. Библиотека будет управлять куки в своем `.pkl` файле после инициализации.
    ```python
    # Импорт из файла Netscape при первом запуске
    api = LensAPI(config={'cookies': '/путь/к/cookie_file.txt'})
    ```
    ```python
    # Импорт из строки заголовка при первом запуске
    api = LensAPI(config={'cookies': '__Secure-ENID=...; NID=...'})
    ```
    ```python
    # Импорт из словаря при первом запуске
    api = LensAPI(config={'cookies': {'__Secure-ENID': {'name': '...', 'value': '...'}, 'NID ': {'имя': '...', 'значение': '...'}}})
    ```

-   **`debug`**: Включает отладочное логирование.
    -   `'info'`: Включает информационное логирование (уровень `logging.INFO`).
    -   `'debug'`: Включает подробное отладочное логирование (уровень `logging.DEBUG`). Переопределяет параметр `logging_level` в конструкторе `LensAPI`.
    ```python
    api = LensAPI(config={'debug': 'debug'})
    ```

-   **`debug_out`**: указывает путь к файлу для сохранения сырого ответа метаданных API для целей отладки, когда уровень `debug` установлен в `'debug'`.
    ```python
    api = LensAPI(config={'debug': 'debug', 'debug_out': '/путь/к/response_debug.json'})
    ```

-   **`rate_limiting`**: Настраивает параметры ограничения скорости.
    -   **`max_requests_per_minute`**: Устанавливает максимальное количество запросов в минуту (RPM). По умолчанию около 30, если не установлено.
    ```python
    api = LensAPI(config={'rate_limiting': {'max_requests_per_minute': 20}})
    ```

</details>

<details>
  <summary><b>Управление куки</b></summary>

Эта библиотека автоматически управляет куки, используя файл `cookies.pkl`, который хранится в каталоге конфигурации пользователя по умолчанию.

Вы можете **импортировать** куки при инициализации, используя опцию `cookies` в словаре `config` при создании экземпляра `LensAPI`, или через флаг `-c` в CLI. Поддерживаемые форматы импорта:

1.  **Файл формата Netscape**: Укажите путь к файлу.

    *   Используйте расширения для браузера, такие как [Cookie Editor](https://chromewebstore.google.com/detail/cookie-editor/hlkenndednhfkekhgcdicdfddnkalmdm) (Chrome) или [Cookie Editor](https://addons.mozilla.org/en-US/firefox/addon/cookie-editor/) (Firefox), чтобы экспортировать куки в этом формате.

    **Программный API (Первоначальный импорт)**:
    ```python
    api = LensAPI(config={'cookies': '/путь/к/google_cookies.txt'})
    ```
    **CLI (Первоначальный импорт)**:
    ```bash
    lens_scan путь/к/изображению.jpg all -c /путь/к/google_cookies.txt
    ```

2.  **Строка заголовка Cookie**: Укажите строковое значение HTTP-заголовка `Cookie:`.

    **Программный API (Первоначальный импорт)**:
    ```python
    api = LensAPI(config={'cookies': '__Secure-ENID=...; NID=...'})
    ```

3.  **Словарь Cookie**: Укажите словарь, где ключи — это имена куки, а значения — либо строковое значение куки, либо другой словарь с деталями, такими как `name`, `value`, `expires`.

    **Программный API (Первоначальный импорт)**:
    ```python
    config = {
        'cookies': {
            '__Secure-ENID': 'значение1.....',
            'NID': 'значение2.....'
         }
    }
    # ИЛИ более подробно:
    # config = {
    #    'cookies': {
    #        '__Secure-ENID': {'name': '__Secure-ENID', 'value': 'значение1', 'expires': 1756858205},
    #        'NID': {'name': 'NID', 'value': 'значение2', 'expires': 1756858205}
    #    }
    # }
    api = LensAPI(config=config)
    ```

**Примечание**: После инициализации библиотека управляет куки внутри себя, используя `cookies.pkl`. Опции импорта в основном предназначены для *первого запуска* или если вам нужно принудительно перезагрузить куки. Куки, полученные от сервера во время запросов, автоматически обновят внутреннее хранилище и файл `.pkl`.

</details>

<details>
  <summary><b>Поддержка прокси</b></summary>

Вы можете выполнять запросы через прокси-сервер, используя API или CLI. Библиотека поддерживает HTTP, HTTPS и SOCKS4/5 прокси через `httpx`.

*   **Установка прокси в API**:

    ```python
    config = {
        'proxy': 'socks5://127.0.0.1:7265' # Ваш адрес прокси
    }
    api = LensAPI(config=config)
    ```
*   **Установка прокси в CLI**:

    ```bash
    lens_scan путь/к/изображению.jpg all -p socks5://127.0.0.1:7265
    ```

</details>

<details>
  <summary><b>Методы программного API</b></summary>

**Важно: Асинхронные методы**

**Все методы получения данных класса `LensAPI` являются асинхронными и ДОЛЖНЫ вызываться с `await` изнутри `async` функции.**

-   **`async get_all_data(image_source, coordinate_format='percent')`**: Возвращает словарь, содержащий все доступные данные (язык, полный текст, координаты, сшитый текст) для данного источника изображения.
    -   `image_source`: Путь к файлу изображения, URL изображения, объект PIL Image, массив NumPy или байты.
    -   `coordinate_format` (str, optional): Формат вывода координат (`'percent'` или `'pixels'`). По умолчанию `'percent'`.
-   **`async get_full_text(image_source)`**: Возвращает основной реконструированный полный текст (строка). Соответствует `full_text_default` в CLI.
    -   `image_source`: Путь к файлу изображения, URL изображения, объект PIL Image, массив NumPy или байты.
-   **`async get_text_with_coordinates(image_source, coordinate_format='percent')`**: Возвращает список словарей, каждый из которых содержит текст слова, координаты (список bbox) и угол (`angle_degrees`). Соответствует `coordinates` в CLI.
    -   `image_source`: Путь к файлу изображения, URL изображения, объект PIL Image, массив NumPy или байты.
    -   `coordinate_format` (str, optional): Формат вывода координат (`'percent'` или `'pixels'`). По умолчанию `'percent'`.
-   **`async get_stitched_text_smart(image_source)`**: Возвращает текст, сшитый с использованием умного метода (реконструкция строк) (строка). Соответствует `full_text_new_method` в CLI.
    -   `image_source`: Путь к файлу изображения, URL изображения, объект PIL Image, массив NumPy или байты.
-   **`async get_stitched_text_sequential(image_source)`**: Возвращает текст, сшитый с использованием базового последовательного метода (строка). Соответствует `full_text_old_method` в CLI.
    -   `image_source`: Путь к файлу изображения, URL изображения, объект PIL Image, массив NumPy или байты.
-   **`async close_session()`**: Закрывает базовую сетевую сессию. **Следует вызывать, когда вы закончили использовать экземпляр API.**

</details>

<details>
  <summary><b>Работа с координатами</b></summary>

API возвращает информацию о координатах для каждого распознанного слова. Эта информация предоставляется в списке `text_with_coordinates` при использовании `get_all_data` или `get_text_with_coordinates`. Каждый элемент в списке представляет собой словарь, содержащий:

-   **`"text"`**: Распознанное слово (строка).
-   **`"coordinates"`**: Список, представляющий ограничивающую рамку (`bbox`). Формат обычно `[center_y, center_x, height, width, angle_in_radians?, confidence_score?]`.
    -   `center_y`, `center_x`: Координаты центра ограничивающей рамки относительно размеров изображения (от 0.0 до 1.0).
    -   `height`, `width`: Размеры ограничивающей рамки относительно размеров изображения (от 0.0 до 1.0).
    -   `angle_in_radians`: Угол поворота рамки (опционально, может отсутствовать). 0 означает отсутствие поворота. Это значение остается в радианах, как получено от API.
    -   `confidence_score`: Оценка уверенности OCR (опционально).
-   **`"angle_degrees"`** (опционально): Угол поворота, удобно преобразованный в **градусы**. Этот ключ добавляется библиотекой, если угол в радианах присутствовал в исходном списке `coordinates`. Положительное значение — по часовой стрелке, отрицательное — против часовой.

Координаты (`center_y`, `center_x`, `height`, `width`) являются относительными к размерам изображения (верхний левый угол — `(0.0, 0.0)`, нижний правый — `(1.0, 1.0)`), если не используется `coordinate_format='pixels'`.

#### Пример записи с координатами

```json
{
  "text": "Пример",
  "coordinates": [
    0.5123,    // center_y (относительная)
    0.3456,    // center_x (относительная)
    0.087,     // height (относительная)
    0.25,      // width (относительная)
    -0.174533, // угол (радианы, примерно -10 град)
    0.95       // уверенность
  ],
  "angle_degrees": -10.0  // Угол, автоматически конвертированный в градусы
}
```

#### Использование формата координат (`percent` vs `pixels`)

Вы можете выбрать формат вывода для значений в списке `coordinates`:

-   **`'percent'` (По умолчанию)**: Значения остаются относительными (от 0.0 до 1.0).
-   **`'pixels'`**: Первые четыре значения (`center_y`, `center_x`, `height`, `width`) преобразуются в абсолютные значения в пикселях на основе **исходных размеров** изображения. Угол (в радианах) и уверенность внутри списка `coordinates` остаются без изменений. Ключ `angle_degrees` не затрагивается.

##### **В консоли**

Используйте флаг `--coordinate-format`:

```bash
# Вывод координат в пикселях:
lens_scan image.jpg coordinates --coordinate-format=pixels
```

##### **В API**

Передайте параметр `coordinate_format` в соответствующие методы:

```python
import asyncio
from chrome_lens_py import LensAPI

async def main():
    api = LensAPI()
    image_path = 'image.jpg'
    # Получение данных с координатами в пикселях
    result = await api.get_text_with_coordinates(image_path, coordinate_format='pixels') # Используйте await!
    print(result)
    await api.close_session() # Не забудьте закрыть сессию

if __name__ == "__main__":
    asyncio.run(main())
```

#### **Важные примечания**

-   Преобразование в пиксели использует **исходные** размеры изображения, обнаруженные до любого изменения размера для запроса API.
-   Ключ `angle_degrees` предоставляет угол в градусах независимо от настройки `coordinate_format`. Значение угла *внутри* списка `coordinates` всегда остается в радианах (если изначально присутствовало).

</details>

<details>
  <summary><b>Отладка и Логирование</b></summary>

При использовании инструмента командной строки `lens_scan` вы можете управлять уровнем логирования с помощью флага `--debug`. Доступны два уровня:

-   `--debug=info`: Включает логирование информационных сообщений (`logging.INFO`).
-   `--debug=debug`: Включает подробные отладочные сообщения (`logging.DEBUG`), включая потенциально конфиденциальные данные.

**Примеры использования:**

```bash
# Запуск с информационным логированием:
lens_scan путь/к/изображению.jpg all --debug=info

# Запуск с подробным отладочным логированием:
lens_scan путь/к/изображению.jpg all --debug=debug
```

При использовании `--debug=debug` вы также можете использовать `--debug-out <путь>` для сохранения сырого ответа метаданных JSON от API в указанный файл (например, `--debug-out response.json`). Это полезно для изучения необработанной структуры данных.

#### Программная Отладка

При использовании API в ваших Python-скриптах вы можете управлять уровнем логирования, настраивая модуль `logging` Python и передавая параметр `logging_level` (например, `logging.DEBUG`, `logging.INFO`) при создании экземпляра `LensAPI`, или установив `debug` (`'info'` или `'debug'`) в `config`.

**Пример использования:**

```python
import asyncio
import logging
from chrome_lens_py import LensAPI

async def main():
    # Настройка базового логирования для приложения
    # logging.basicConfig(level=logging.DEBUG) # Можно установить глобальный уровень здесь

    # Создаем экземпляр API с уровнем DEBUG и указываем файл для вывода отладки
    api = LensAPI(
        logging_level=logging.DEBUG,
        config={'debug_out': 'api_response.json'}
    )
    # Или используя config:
    # api = LensAPI(config={'debug': 'debug', 'debug_out': 'api_response.json'})

    try:
        result = await api.get_all_data('путь/к/изображению.jpg') # Используйте await!
        print(result)
    finally:
        await api.close_session() # Убедитесь, что сессия закрыта

if __name__ == "__main__":
    # Установка формата для логирования, если basicConfig не использовался или требует переопределения
    log_format = '%(asctime)s - %(levelname)s - %(name)s - %(message)s'
    logging.basicConfig(level=logging.INFO, format=log_format) # Установка уровня по умолчанию для запуска скрипта
    asyncio.run(main())
```

Параметр `logging_level` в конструкторе `LensAPI` (или `debug` в `config`) контролирует подробность внутреннего логирования библиотеки.

Когда уровень установлен на `logging.DEBUG` (или `debug: 'debug'`), библиотека будет выводить подробную информацию. Если также указан `debug_out` в конфигурации, сырой ответ метаданных будет сохранен.

</details>

<details> <summary><b>Управление конфигурацией</b></summary>

### Приоритет конфигурации

Настройки определяются в следующем порядке (сначала самый высокий приоритет):

1.  **Аргументы командной строки (CLI)**
2.  **Переменные окружения** (`LENS_SCAN_PROXY`, `LENS_SCAN_COOKIES`, `LENS_SCAN_CONFIG_PATH`)
3.  **Файл конфигурации** (указанный через `--config-file`, переменную окружения или найденный по умолчанию)
4.  **Значения по умолчанию**, встроенные в библиотеку.

### Файл конфигурации по умолчанию

*   Хранится в каталоге конфигурации пользователя, специфичном для ОС (например, `~/.config/chrome-lens-py/config.json` в Linux, `~/Library/Application Support/chrome-lens-py/config.json` в macOS, `%USERPROFILE%/.config/chrome-lens-py/config.json` в Windows). Имя файла: `config.json`.

### Указание пользовательского файла конфигурации

*   Используйте `--config-file путь/до/вашего/config.json` или установите `LENS_SCAN_CONFIG_PATH`.
*   Пользовательские файлы конфигурации доступны **только для чтения** и не обновляются флагом `-uc`.

### Настройки конфигурации (Файл JSON)

*   **`proxy`** (string): URL прокси-сервера (например, `"socks5://user:pass@host:port"`).
*   **`cookies`** (string или dict): Начальные куки для импорта (путь, строка заголовка или словарь). См. раздел Управление куки.
*   **`coordinate_format`** (string): `"percent"` или `"pixels"`.
*   **`debug`** (string): `"info"` или `"debug"`. Контролирует уровень логирования.
*   **`debug_out`** (string): Путь для сохранения сырого ответа метаданных, когда `debug` равен `"debug"`.
*   **`data_type`** (string): Тип данных по умолчанию для CLI (`"all"`, `"full_text_default"` и т.д.).
*   **`rate_limiting`** (dict): Настройки ограничения скорости.
    *   **`max_requests_per_minute`** (int): Максимальное количество запросов в минуту (например, `30`).

*Устаревшие настройки (игнорируются): `sleep_time`, `header_type`.*

### Пример `config.json`

```json
{
  "proxy": "socks5://username:password@proxy.example.com:1080",
  "cookies": "path/to/your/cookie_file.txt",
  "coordinate_format": "percent",
  "debug": "info",
  "debug_out": null,
  "data_type": "all",
  "rate_limiting": {
    "max_requests_per_minute": 25
  }
}
```

### Обновление файла конфигурации по умолчанию (`-uc`)

*   Используйте флаг `-uc` или `--update-config` в CLI, чтобы сохранить некоторые настройки из текущего запуска *только в файл конфигурации по умолчанию*.
*   **Обновляются**: `coordinate_format`, `debug`, `data_type`, `rate_limiting.max_requests_per_minute`, `debug_out`.
*   **НЕ обновляются**: `proxy`, `cookies`.

### Переменные окружения

*   `LENS_SCAN_PROXY`: Переопределяет прокси из конфига/CLI.
*   `LENS_SCAN_COOKIES`: Переопределяет куки из конфига/CLI для первоначального импорта.
*   `LENS_SCAN_CONFIG_PATH`: Указывает путь к файлу конфигурации, переопределяя стандартное расположение.

</details>

<details>
<summary><b>Пакетная Обработка (Ввод каталога)</b></summary>

### Обработка нескольких изображений в каталоге

Укажите путь к каталогу в качестве `<image_source>`, чтобы обработать все поддерживаемые изображения внутри него с помощью CLI.

#### Использование CLI

```bash
lens_scan путь/к/каталогу [data_type] [опции]
```

*   **`путь/к/каталогу`**: Путь к каталогу, содержащему изображения.
*   **`[data_type]`**: Тип данных для извлечения (например, `all`, `full_text_default`).
*   **`[опции]`**: Такие как `--out-txt`, `--rate-limit-rpm`.

**Пример:**

```bash
lens_scan /путь/к/изображениям all --out-txt=per_file --rate-limit-rpm=20
```

#### Опции вывода с помощью `--out-txt` (для ввода каталога)

*   **`--out-txt=per_file`**: Сохраняет каждый результат в отдельный файл `.txt` с именем изображения в исходном каталоге.
*   **`--out-txt=имя_файла.txt`**: Сохраняет все результаты вместе в указанный файл в исходном каталоге.
*   **Если `--out-txt` НЕ используется**: Результаты для каждого файла выводятся в консоль последовательно. Комбинированный файл вывода по умолчанию не создается.

**Примеры:**

1.  **Вывод в отдельные файлы:**
    ```bash
    lens_scan /путь/к/изображениям all --out-txt=per_file
    ```
    (Создает `image1.txt`, `image2.txt` и т.д. в `/путь/к/изображениям`)

2.  **Вывод всего в один файл:**
    ```bash
    lens_scan /путь/к/изображениям all --out-txt=общие_результаты.txt
    ```
    (Создает `общие_результаты.txt` в `/путь/к/изображениям`)

3.  **Вывод в консоль (По умолчанию для каталога):**
    ```bash
    lens_scan /путь/к/изображениям full_text_new_method
    ```
    (Выводит результаты для каждого изображения в стандартный вывод)

#### Формат вывода (Комбинированный файл)

При использовании `--out-txt=имя_файла.txt` формат файла вывода следующий:

```plaintext
# --- Result for: image1.jpg ---
{ ... JSON или текстовый результат ... }

# --- Result for: image2.png ---
{ ... JSON или текстовый результат ... }

# --- FAILED processing: image3.gif ---

...
```

#### Ограничение скорости

Внутренний ограничитель скорости автоматически управляет задержками между запросами на основе настроенного RPM (`--rate-limit-rpm` или файл конфигурации). Старый флаг `--sleep-time` игнорируется.

#### Программное использование API для пакетной обработки

В настоящее время программный API (методы `LensAPI`) принимает только одиночные источники изображений (путь, URL, PIL, NumPy, байты). **Логика пакетной обработки (перебор каталога) должна быть реализована в вашем собственном коде** с использованием методов API для одиночных источников. См. пример в предыдущей версии `README.md` или в тестовом скрипте для руководства.

#### Примечания:

*   **Поддерживаемые файлы**: CLI в режиме каталога обрабатывает только файлы, распознанные `filetype` как поддерживаемые типы изображений.
*   **Ограничение скорости**: Убедитесь, что ваши настройки RPM разумны для больших каталогов.
*   **Обработка ошибок**: Ошибки при обработке отдельных файлов логируются и обычно приводят к записи об ошибке при программном сборе результатов или выводятся в консоль/файл в режиме CLI.

</details>

## Структура проекта

```plain
/chrome-lens-api-py
│
├── /src
│   ├── /chrome_lens_py
│   │   ├── __init__.py           # Инициализация пакета
│   │   ├── constants.py          # Константы (Эндпоинты, Заголовки)
│   │   ├── exceptions.py         # Пользовательские исключения
│   │   ├── utils.py              # Вспомогательные функции (проверка mime, пути, url)
│   │   ├── cookies_manager.py    # Обработка куки (хранение PKL, импорт)
│   │   ├── image_processing.py   # Изменение размера изображений, конвертация форматов
│   │   ├── request_handler.py    # Основная логика асинхронных HTTP запросов (LensCore, Lens)
│   │   ├── text_processing.py    # Парсинг ответа API, сшивание текста
│   │   ├── lens_api.py           # Публичный асинхронный интерфейс API (LensAPI)
│   │   └── main.py               # Точка входа CLI инструмента (использует LensAPI)
│
├── setup.py                      # Установка проекта
├── README.md                     # Английское описание
├── README_RU.md                  # Этот файл
├── LICENSE                       # Файл лицензии MIT
└── requirements.txt              # Зависимости проекта
```

## Благодарности

Особая благодарность [dimdenGD](https://github.com/dimdenGD) за оригинальный метод извлечения текста, использованный в ранних версиях, и за вдохновение. Вы можете ознакомиться с его работой в репозитории [chrome-lens-ocr](https://github.com/dimdenGD/chrome-lens-ocr).

## TODO

- [X] Добавить "сканирование по URL"
- [X] Добавить вывод в пикселях
- [X] Поддержка ввода из PIL-изображений и NumPy-массивов
- [X] Реализовать ограничение скорости (автоматическое с помощью внутреннего ограничителя)
- [X] Преобразовать библиотеку в `асинхронную` /`ожидающую`, используя "httpx".
- [X] Добавить угол в градусах для вывода координат.
- [ ] Добавить поддержку выгрузки переведенного изображения (да, он такое теперь тоже умеет, на любой язык(почти)).
- [ ] Пересмотреть требования к импорту/экспорту файлов cookie (теперь основным является `.pkl`).

## Лицензия

Этот проект лицензирован на условиях лицензии MIT. Подробнее см. в файле [LICENSE](LICENSE).

## Отказ от ответственности

Этот проект предназначен только для образовательных целей. Использование функциональности OCR Google Lens должно соответствовать условиям использования Google. Автор этого проекта не несет ответственности за любое неправильное использование этого программного обеспечения или за любые последствия, возникающие из его использования. Пользователи несут полную ответственность за обеспечение того, что использование этого программного обеспечения соответствует всем применимым законам и нормативным актам.

## Автор

### Bropines - [Почта](mailto:bropines@gmail.com) / [Telegram](https://t.me/bropines)

Спешал фор рускоговорящих. Да, ридми был написан GPT-шкой. Мне было ооооооочень лень его писать ручками :)
